<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Hello World</title>
	<script src="../caller.js"></script>
</head>
<body>

	<script async>
		let parameter = {};

    parameter.파라미터기본값 = function() {
      //ES5
      function plus(x, y) {
        x = x || 0;
        y = y || 0;

        return  x + y
      }

      console.log(plus());
      console.log(plus(1, 2));

      //ES6
      function plus(x = 0, y = 0) {
        return x + y;
      }

      console.log(plus());
      console.log(plus(1, 2));
    }

    parameter.rest파라미터기본문법 = function() {
      function foo(...rest) {
        console.log(Array.isArray(rest)); //true

        console.log(rest);
      }

      foo(1,2,3,4,5);

      function foo(param, ...rest) {
        console.log(param); //1
        console.log(rest); // [2,3,4,5]
      }

      foo(1,2,3,4,5);

      function bar(param1, param2, ...rest) {
        console.log(param1); //1
        console.log(param2); //2
        console.log(rest); //[3,4,5]
      }

      bar(1,2,3,4,5); //rest 파라미터는 반드시 마지막 파라미터여야 한다.
    }

    parameter.argument와rest파라미터 = function() {
      // ES5
      var foo = function() {
        console.log(arguments);
      };

      foo(1,2); // [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]

      // ES6
      function sum(...args) {
        console.log(arguments);
        console.log(args);

        return args.reduce((pre,cur) => pre + cur);
      }

      console.log(sum(1,2,3,4,5));

      var normalFunc = function() {};
      console.log(normalFunc.hasOwnProperty('arguments'));

      var arrowFuc = () => {}
      console.log(arrowFuc.hasOwnProperty('arguments')); //arrow 펑션은 arguments가 없다.
    }

    parameter.spread연산자 = function() {
      //spread연산자 (spread operator, ...)는 피연산자를 개별 요소로 분리한다. spread 연산자의 피연산자는 이터러블이어야 한다.

      // ...[1,2,3] 는 [1,2,3]dmf roquf dythfh qnsflgksek (-> 1,2,3)
      console.log(...[1,2,3]); //1,2,3

      // 문자열을 이터러블이다.
      console.log(...'Hello'); // H e l l o

      //Map과 Set은 이터러블이다.
      console.log(...new Map([['a', 'b'], ['b', '2']]));
      console.log(...new Set([1,2,3])); // 1 2 3

      // 이터러블이 아닌 일반 객체는 Spread 연산자의 피연산자가 될 수 없다.
      // console.log(...{ a: 1, b: 2 });
      // TypeError: Found non-callable @@iterator
    }

    parameter.함수의인수로사용하는경우 = function() {
      //ES5
      function foo(x,y,z) {
        console.log(x); //1
        console.log(y); //2
        console.log(z); //3
      }
      //배열을 분해하여 배열의 각 요소를 파라미터에 전달하려고 한다
      const arr = [1,2,3];

      // ES6
      function foo(x,y,z) {
        console.log(x); //1
        console.log(y); //2
        console.log(z); //3
      }
      //배열을 foo 함수의 인자로 전달하려고 한다.
      const arr1 = [1,2,3];
      //...[1,2,3]은 [1,2,3]을 개별 요소로 분리한다  > 1,2,3
      //spread 연산자에 의해 분리된 배열의 요소는 개별적인 인자로서 각각의 매개변수에 전달된다.
      foo(...arr1);

      //rest파라미터는 반드시 마지막 파라미터여야 하지만 spread연산자를 사용한 인수는 자유롭게 사용할 수 있다.
      //ES6
      function foo(v,w,x,y,z) {
        console.log(v); //1
        console.log(w); //2
        console.log(x); //3
        console.log(y); //4
        console.log(z); //5
      }

      foo(1, ...[2, 3], 4, ...[5]);
    }

    parameter.concat = function() {
      //ES5
      var arr = [1,2,3];
      console.log(arr.concat([4,5,6])); //[1,2,3,4,5,6]

      //ES6
      const arr1 = [1,2,3];
      //...arr는 [1,2,3]을 개별요소로 분리 spread
      console.log([...arr,4,5,6]); //[1,2,3,4,5,6]
    }

    parameter.push = function() {
      //ES5 
      var arr1 = [1,2,3];
      var arr2 = [4,5,6];

      // apply 메소드의 2번째 인자는 배열. 개별 이자로 push 메소드에 전달된다.
    }

    Caller.execute(parameter); // 모든 메소드를 실행하는 모듈
  </script>
</body>
</html>